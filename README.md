**ТЗ:** https://docs.google.com/document/d/169qvEBsGmgwnMar5MQ0CnN5URONzLMtT4wXp5DIyo6c/edit?tab=t.0

**Кодстайл:** default C# practice + private/protected сущности с нижнего подчёркивания, public/unity методы вверху, return выражение с новой строки для удобства дебаггинга, вместо логического отрицания !value - более явное/читаемое глазу value == false.
В коде в некоторых местах оставил пометки по тому или иному вопросу. Учитывая кодстайл, делал их на английском. Это всё обсуждаемо в зависимости от команды.
Где-то у методов решил делать epression body, где-то statement в зависимости от того понадобится ли дебажить метод.

**Подход:** думал взять сначала ECS, т.к. статы персонажа/модификаторы хорошо ложаться на Entity с подобным геймплеем ибо делал похожую карточную механику на Entitas.
Однако всё же предпочёл остаться на ООП из рабочих соображений т.к. на работе он чаще всего юзался другими программистами => проще коммуницировать между собой.

**Архитектура:** подходил к ней как не к ТЗ (пускай оно и не такое сложное, можно на MonoBehaviour всё было сделать), а к реальному проекту, который нужно будет развивать
- Точка входа: стартовая сцена InitialScene (запускать с неё) и BootstrapInstaller - биндятся основные сервисы здесь. В качестве DI-Container-а выбран Zenject в демонстрационных целях.
- Стейты-приложения: игра разбита на стейты, позволяя удобно их отделять. BootstrapState прогревает статик дату, InitializeNaniState - иницианизирует нани (делаю это отдельно т.к. иногда отключаю его для тестов + дальше по пайплайну нужно инжектить его UI)
- RegisterNaniState: учитывая не самую удобную фабрику нани (без возможности override), бинд зависимостей по наниновел части происходит здесь.
- ConstructNaniUIState: инъект моих сервисов в Custom UI, где это требуется
- BattleEnterState и BattleLoopState: подготовка к тестовому геймплею ТЗ и сам зацикленный геймплей непосредственно.
- Все лайфайм сущности билдятся рантайм через фабрику GameFactory (кроме тайлмапы деревни, т.к. на ней составляются локации). Фабрика пока что не такая больашя, но в будущем бы разделил на несколько других фабрик, если бы выросла дальше.
- Обращение к статик дате (prefabs assets/SO) - происходит через сервис StaticData. Там реализация ассет провайдера на Resources, у меня есть аналогичная на Addressables но в рамках ТЗ решил не подключать её.
  + пока нет смысла работать с загрузкой/выгрузкой ассетов, не того типа игра.
- Service-ориентированная модель, где логика и обращения проистекает через свои небольшие сервисы.


**По части кода**: где-то сразу сделал абстаркции, зная, что в таком типе игр скорее всего это пришлось бы сделать в будущем, где-то остановился на более явных реализациях в рамках ТЗ и сроков.

**Что я добавил сверх ТЗ:**
- Свап карт между собой, анимации, графику

- Возможность указать локации, к которым прикрепляются ивенты (к одной локации может быть несколько ивентов прикреплено)
Подумал как это будет попроще для геймдиза (в рамках ТЗ и времени, конечно) - просто расставить LocationPoints и нажать Collect, они автоматически подхватятся. Если гейм диз совсем не знаком с юнити можно ещё более script-kids систему придумать.

<img width="1920" height="515" alt="Points" src="https://github.com/user-attachments/assets/a90b8e64-98f8-44a2-8b91-fe03ddc93b44" />


- Гибкую систему модификаторов статов (можно выбрать Mode: Stack/Instance), если Stack - то модификатор одного и того же типа будет стакаться (по-прежнему увеличивая Value-баффа/дебаффа) и отображаться как один эффект на карте,
если Instance - отображаемых эффектов одного и того же типа будет несколько. Статы отделены от модификаторов статов.
<img width="671" height="283" alt="StatModifierConfig" src="https://github.com/user-attachments/assets/48fb8882-2380-41ef-977d-92f0f7552f39" />

Пример с тем же эффектом, но Instance-типа:

<img width="138" height="195" alt="instance" src="https://github.com/user-attachments/assets/27e5a248-83c0-48d9-ab73-7f36a41a26ec" />


Конфиг довольно гибкий (для ТЗ), позволяющий указывать различные модификаторы к статам

- Тоже самое про ивенты, где каждый можно настроить: время выполнения, экспа, таргетный power и View

<img width="493" height="609" alt="EventsConfig" src="https://github.com/user-attachments/assets/b025c3c9-828a-4c7b-a0ee-8f441c634d56" />

- В т.ч. время и тип анимации карт:

<img width="490" height="161" alt="MoveTo" src="https://github.com/user-attachments/assets/422112fa-2e9d-4ad1-b88f-7d08d6a3fcf4" />

Стартовые доступные герои также указываются в конфигах.

Важно: все конфиги, в которых фигурирует Name/Lable/Description сейчас используют Raw значения. В реальном проекте это были бы локализируемые ключи.

- LogVersion - база моего любого рабочего проекта для удобства дебагинга и просмотр версии.

+ ещё всякое по мелочи вне ТЗ.

Empty bar выполнения задания оставил /by design/, чтоб было видно, что квест ещё не зафинален с результатом. Можно заменить на иконку, мол квест выполнен.

**Как прошёл пайплайн:**

**Первый день:** ознакомление с ТЗ, базовая архитектура проекта, геймплейные сервисы, конфиги и логика. Здесь я тестировал логику исключительно на уровне кода, без View-отображения или сцены.
К концу дня - прототип игры уже с тестовой грейбоксинг view-графикой рендером карт персонажей и заданиями.

**Второй день:** более полноценная сервисная логика по задачам из ТЗ, поиск ассетов и добавление ассет-графики, UI.

**Третий день:** доп. таски. Фиксы.

**Четвертый день:** полишинг, рефакторинг, взгляд на весь код "целиком", немного анимаций, + немного подумал над более приятным user experience (например более привлекающие взгляд задания) пускай графика всё ещё тестовая.

С какими-либо трудностями не столкнулся, довольно привычные для меня задачи. В целом было залипательно делать такие механики, нравятся карточные игры.

Что думаю бы добавил в реальном проекте (за исключением графики с нормальной палитрой, звуков и прочих artist-based вещей):
- Build panel меню с удобным в один клик вкл/выкл дефайнами, а также авто проставлением версии для билда на основе коммитов
- gravity/инерцию карт, их угол наклона в зависимости от того, откуда идёт движение
- Скорее всего CI-интеграция для облачных билдов, но посмотрел бы как часто билды делаются. Иногда это овербилдинг
- Заменить часть конфигов где фигурирует текстовое Id на пустышки-SO-интерпертации сущностей (включают в себя только вшитый ID в виде имени), чтобы прокидывать в инспекторе их, а не Id
- Подумал бы над юзер экспириенсом
- Может быть глянул бы в сторону URP для небольшой динамики и лёгкой освещенности и приятности глазу, тут нужно смотреть на стилистику проекта уже

**Git commits:** немного хаотичные получились, обычно я делаю по Git Flow с фича ветками. Поэтому в этом репо смерджил в один.
